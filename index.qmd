---
title : Advent of Code 2022
subtitle: "[adventofcode.com](https://adventofcode.com/){.aoc-yellow}"
#author: Jo Dudding
#date: today
format: 
  html:
    #embed-resources: true
    #standalone: true
    fig-width: 8
    fig-height: 4
    theme: ['advent-of-code.scss']
    highlight-style: nord
    toc: true
    toc_float: 
      collapsed: true
    code-fold: true  
execute: 
  echo: true
  warning: false
  message: false
knitr: 
  opts_knit: 
    root-dir: "`r here::here()`"
---

# Introduction

This analysis is my attempt at [adventofcode.com](https://adventofcode.com/) using R and Quarto.

Here's an overview from [adventofcode.com](https://adventofcode.com/).

> Santa's reindeer typically eat regular reindeer food, but they need a lot of magical energy to deliver presents on Christmas. For that, their favorite snack is a special type of [star]{.aoc-yellow} fruit that only grows deep in the jungle. The Elves have brought you on their annual expedition to the grove where the fruit grows.
> 
> To supply enough magical energy, the expedition needs to retrieve a minimum of [fifty stars]{.aoc-yellow} by December 25th. Although the Elves assure you that the grove has plenty of fruit, you decide to grab any fruit you see along the way, just in case.
> 
> Collect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants [one star]{.aoc-yellow}. Good luck!


```{r}
#| label: setup

library(tidyverse)
library(scales)
library(here)
library(gfonts)
library(patchwork)

options(
  dplyr.width = Inf,
  papersize = "a4",
  tab.width = 2,
  width = 80,
  max.print = 25,
  stringsAsFactors = FALSE,
  lubridate.week.start = 6,
  tibble.print_max = 25,
  tibble.print_min = 25,
  tibble.width = Inf,
  dplyr.summarise.inform = FALSE,
  tidyverse.quiet = TRUE
)

source('aoc-theme.r')

stars <- 0

```

# Day 1: Calorie Counting

[Instructions](https://adventofcode.com/2022/day/1)

```{r}
#| label: read-day1-part1
df1 <- tibble(cals = readLines('inputs/day1-part1.csv')) |>
  mutate(
    cals = as.numeric(cals),
    row = row_number(),
    elf = case_when(
      row == 1 ~ row,
      is.na(cals) ~ row
    )
  ) |>
  fill(elf) |>
  filter(!is.na(cals)) |>
  group_by(elf) |>
  summarise(cals = sum(cals)) |>
  ungroup() |>
  arrange(-cals)

stars <- stars + 1
```

The maximum calories carried by an elf is
[`r comma(max(df1$cals))`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day1-part2

top_3_cals <- df1 |>
  head(3) |>
  summarise(cals = sum(cals)) |>
  pull(cals)

stars <- stars + 1
```

The calories carried by the top three elves is
[`r comma(top_3_cals)`]{.aoc-green}. [*]{.aoc-yellow}

# Day 2: Rock Paper Scissors

[Instructions](https://adventofcode.com/2022/day/2)

```{r}
#| label: read-day2-part1
df2 <- tibble(strat = readLines('inputs/day2-part1.csv')) |>
  separate(strat, into = c('them', 'us')) |>
  mutate(
    shape = case_when(
      us == 'X' ~ 1,
      us == 'Y' ~ 2,
      us == 'Z' ~ 3
    ),
    outcome = case_when(
      them == 'A' & us == 'X' ~ 3,
      them == 'A' & us == 'Y' ~ 6,
      them == 'A' & us == 'Z' ~ 0,
      them == 'B' & us == 'X' ~ 0,
      them == 'B' & us == 'Y' ~ 3,
      them == 'B' & us == 'Z' ~ 6,
      them == 'C' & us == 'X' ~ 6,
      them == 'C' & us == 'Y' ~ 0,
      them == 'C' & us == 'Z' ~ 3
    ),
    score = shape + outcome
  ) 

stars <- stars + 1

```

The total points for this strategy are
[`r comma(sum(df2$score))`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day2-part2

df2_p2 <- df2 |>
  mutate(
    outcome = us,
    us = case_when(
      them == 'A' & outcome == 'X' ~ 'Z',
      them == 'A' & outcome == 'Y' ~ 'X',
      them == 'A' & outcome == 'Z' ~ 'Y',
      them == 'B' & outcome == 'X' ~ 'X',
      them == 'B' & outcome == 'Y' ~ 'Y',
      them == 'B' & outcome == 'Z' ~ 'Z',
      them == 'C' & outcome == 'X' ~ 'Y',
      them == 'C' & outcome == 'Y' ~ 'Z',
      them == 'C' & outcome == 'Z' ~ 'X'
    ),
    shape_points = case_when(
      us == 'X' ~ 1,
      us == 'Y' ~ 2,
      us == 'Z' ~ 3
    ),
    outcome_points = case_when(
      outcome =='X' ~ 0,
      outcome =='Y' ~ 3,
      outcome =='Z' ~ 6
    ),
    score = shape_points + outcome_points
  ) 

stars <- stars + 1
```

The total points for the updated strategy are
[`r comma(sum(df2_p2$score))`]{.aoc-green}. [*]{.aoc-yellow}


# Day 3: Rucksack Reorganization

[Instructions](https://adventofcode.com/2022/day/3)

```{r}
#| label: read-day3-part1

scoring3 <- tibble(
  contents_item = c(letters, LETTERS),
  priority = 1:52
)

df3 <- tibble(contents = readLines('inputs/day3-part1.csv')) |>
  mutate(
    rucksack = row_number(),
    len = str_length(contents),
    contents_item = str_split(contents, "")
  ) |>
  unnest(contents_item) |>
  group_by(rucksack) |>
  mutate(
    compartment = if_else(row_number() <= len / 2, 'a', 'b')
  ) 
  
df3_1 <- df3|>
  distinct(rucksack, contents_item, compartment) |>
  group_by(rucksack, contents_item) |>
  filter(n() > 1) |>
  ungroup() |>
  distinct(rucksack, contents_item) |>
  left_join(scoring3, by = 'contents_item')

stars <- stars + 1

```

The total priority for the rucksacks is
[`r comma(sum(df3_1$priority))`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day3-part2

df3_2 <- df3 |>
  mutate(
    trio = (rucksack - 1) %/% 3
  ) |>
  distinct(rucksack, contents_item, trio) |>
  group_by(trio, contents_item) |>
  filter(n()  == 3) |>
  ungroup() |>
  distinct(contents_item, trio) |>
  left_join(scoring3, by = 'contents_item') 

stars <- stars + 1
```

The total priority for the badges is
[`r comma(sum(df3_2$priority))`]{.aoc-green}. [*]{.aoc-yellow}


# Day 4: Camp Cleanup

[Instructions](https://adventofcode.com/2022/day/4)

```{r}
#| label: read-day4-part1

df4 <- tibble(sections = readLines('inputs/day4-part1.csv')) |> 
  separate(sections, into = c('elf1_min', 'elf1_max', 'elf2_min', 'elf2_max'), convert = TRUE) |> 
  mutate(pair = row_number())

df4_1 <- df4 |> 
  filter(
    (elf1_min <= elf2_min & elf1_max >= elf2_max) |
    (elf2_min <= elf1_min & elf2_max >= elf1_max) 
  ) 

stars <- stars + 1

```

The assignment pairs where one fully contains the other is
[`r comma(nrow(df4_1))`]{.aoc-green}. [*]{.aoc-yellow}


```{r}
#| label: read-day4-part2


df4_2 <- df4 |> 
  filter(
    (elf1_max >= elf2_min & elf1_max <= elf2_max) |
    (elf2_max >= elf1_min & elf2_max <= elf1_max)  
  )

stars <- stars + 1
```


The assignment pairs where they overlap is
[`r comma(nrow(df4_2))`]{.aoc-green}. [*]{.aoc-yellow}


# Day 5: Supply Stacks

[Instructions](https://adventofcode.com/2022/day/5)

```{r}
#| label: read-day5-part1

df5 <- readLines('inputs/day5-part1.csv')

movements <- tibble(crates = df5) |> 
  filter(cumsum(str_trim(crates) == '') > 0 & str_trim(crates) != '') |> 
  separate(crates, into = c('move', 'move_num', 'from', 'stack_from', 'to', 'stack_to'), sep = ' ', convert = TRUE) |> 
  select(-move, -from, -to) 

stack <- df5[cumsum(str_trim(df5) == '') == 0]

stack_nums <- (str_length(tail(stack, 1)) + 1) %/% 4
stack_seq <- seq(2, stack_nums * 4, by = 4)

stack_list <- map(stack_seq, ~rev(str_sub(stack, .x, .x)))
#names(stack_list) = paste0('stack_', 1:stack_nums)
adj_stack <- map(stack_list, ~ .x[str_trim(.x) != ''])


#' need to do
#' get the last item in the from list
#' add it to the end of the to list
#' update the from list to remove it
#' repeat for the number of moves


move <- function(stack_from, stack_to) {
  start_stack <- adj_stack[[stack_from]]
  end_stack <- adj_stack[[stack_to]]
  
  to_move <- tail(start_stack, 1)
  
  adj_stack[[stack_to]] <<- c(end_stack, to_move)
  adj_stack[[stack_from]] <<- start_stack[1:length(start_stack)-1]
}

move_times <- function(move_num, stack_from, stack_to) {
  for(i in 1:move_num) {move(stack_from, stack_to)}
}


pwalk(movements, move_times)


final_stack <- adj_stack

message <- paste(map(final_stack, ~tail(.x, 1)), collapse = '')

stars <- stars + 1

```

The crates on the top of each stack are
[`r message`]{.aoc-green}. [*]{.aoc-yellow}


```{r}
#| label: read-day5-part2

adj_stack <- map(stack_list, ~ .x[str_trim(.x) != ''])

move2 <- function(move_num, stack_from, stack_to) {
  start_stack <- adj_stack[[stack_from]]
  end_stack <- adj_stack[[stack_to]]
  
  to_move <- tail(start_stack, move_num)
  
  adj_stack[[stack_to]] <<- c(end_stack, to_move)
  
  adj_stack[[stack_from]] <<- start_stack[1:(length(start_stack)-move_num)] 
}

pwalk(movements, move2)

final_stack <- adj_stack

message2 <- paste(map(final_stack, ~tail(.x, 1)), collapse = '')


stars <- stars + 1
```

With the new crane the crates on the top of each stack are
[`r message2`]{.aoc-green}. [*]{.aoc-yellow}


# Day 6: Tuning Trouble

[Instructions](https://adventofcode.com/2022/day/6)

```{r}
#| label: read-day6-part1

raw_6 <- readLines('inputs/day6-part1.csv')

df_6 <- tibble(chars = str_split(raw_6, pattern = '')) |>  
  unnest(chars) |> 
  mutate(
    row = row_number(),
    marker = if_else(
      row <= 3,
      FALSE,
     chars != lag(chars, 3) & chars != lag(chars, 2) & chars != lag(chars, 1) &
     lag(chars, 1) != lag(chars, 3) & lag(chars, 1) != lag(chars, 2) & 
     lag(chars, 2) != lag(chars, 3)
    )
  )

sop <- df_6 |> 
  filter(marker == TRUE) |> 
  slice(1) |> 
  pull(row)

stars <- stars + 1

```

The start of packet marker is at
[`r comma(sop)`]{.aoc-green}. [*]{.aoc-yellow}


```{r}
#| label: read-day6-part2

chars <- unlist(str_split(raw_6, pattern = ''))

som <- map_dfc(0:13, ~lag(chars, .x)) |> 
  mutate(row = row_number()) |> 
  filter(row >= 14) |> 
  gather(-row, key = 'lag',value = 'value') |> 
  group_by(row) |> 
  summarise(
    n_distinct = n_distinct(value)
  ) |> 
  filter(n_distinct == 14) |> 
  slice(1) |> 
  pull(row)

stars <- stars + 1
```

The start of message marker is at
[`r comma(som)`]{.aoc-green}. [*]{.aoc-yellow}


# Day 7: No Space Left On Device

[Instructions](https://adventofcode.com/2022/day/7)


```{r}
#| label: read-day7-part1

pth <- function(path, cd) {
  if (!is.na(cd)) {
    if (cd == "..") {
      return(head(path, -1))
    }
    return(c(path, paste0(tail(path, 1), "/", cd)))
  }
  return(path)
}

df_7 <- tibble(instruct = readLines('inputs/day7-part1.csv')) |> 
  mutate(
    row = row_number(),
    command = case_when(
      str_sub(instruct, 1, 1) == '$' ~ str_sub(instruct, 3)
    ),
    #file = case_when(
    #  is.na(command) ~ str_split(instruct, pattern = ' ', n = 2, simplify = TRUE)
    #),
    file_size = as.numeric(str_extract(instruct, '([:alnum:]+)\\b')),
    file_name = if_else(
      !is.na(file_size),
      str_extract(instruct, '(\\b[:alnum:]+\\.[:alnum:]+)$'),
      str_extract(instruct, '(\\b[:alnum:]+)$')
    ),
    type = case_when(
      !is.na(command) ~ 'command',
      !is.na(file_size) ~ 'file',
      TRUE ~ 'folder'
    ),
    cd = case_when(str_sub(command, 1, 2) == 'cd' ~ str_sub(command, 4))
  ) |> 
  select(row, cd, file_size) |> 
  mutate(
    path = accumulate(cd, pth)
  ) |> 
  unnest(path) |> 
  filter(!is.na(file_size)) |> 
  group_by(path) |> 
  summarise(
    file_size = sum(file_size)
  ) |> 
  ungroup()

tot_u100k <- df_7 |> 
  filter(file_size < 100000)  |> 
  summarise(sum(file_size)) |> 
  pull()


stars <- stars + 1

```

The total directory size is
[`r comma(tot_u100k)`]{.aoc-green}. [*]{.aoc-yellow}


```{r}
#| label: read-day7-part2

tot_space <- 70000000
unused_space <- tot_space - max(df_7$file_size)
unused_required <- 30000000
to_delete <- unused_required - unused_space

dir_size <- df_7 |> 
  arrange(file_size) |> 
  filter(file_size >= to_delete) |> 
  head(1) |> 
  pull(file_size)

stars <- stars + 1
```

The best folder to delete has a size of
[`r comma(dir_size)`]{.aoc-green}. [*]{.aoc-yellow}

# Day 8: Treetop Tree House

[Instructions](https://adventofcode.com/2022/day/8)

```{r}
#| label: read-day8-part1
#| fig-height: 8

raw_8 <- readLines('inputs/day8-part1.csv')

visible <- tibble(trees = raw_8) |> 
  mutate(
    tree = str_split(trees, ""),
    row = row_number()
    ) |> 
  group_by(row) |> 
  unnest(tree) |> 
  #filter(row == 1) |> 
  mutate(
    tree = as.numeric(tree),
    column = row_number(),
    row_down = cummax(tree),
    visible = if_else(
      row_number() == 1,
      TRUE,
      tree > lag(row_down)
    ),
    row_up = order_by(-column, cummax(tree)),
    visible = if_else(
      visible | row_number() == n(),
      TRUE,
      tree > lead(row_up)
    )
  ) |> 
  group_by(column) |> 
  mutate(
    row_right = cummax(tree),
    visible = if_else(
      visible | row_number() == 1,
      TRUE,
      tree > lag(row_right)
    ),
    row_left = order_by(-row, cummax(tree)),
    visible = if_else(
      visible | row_number() == n(),
      TRUE,
      tree > lead(row_left)
    ),
  ) |> 
  ungroup()



visible |> 
  ggplot(aes(column, -row, fill =  tree, label = tree)) + 
  geom_tile() +
  #geom_text(colour = aoc_black) +
  scale_fill_gradient(high = aoc_dgreen, low = aoc_yellow) +
  #coord_fixed() +
  theme_aoc_null() +
  labs(
    title = 'Tree heights'
  ) +
  guides(fill = 'none')

stars <- stars + 1

```

The total number of visible trees is
[`r comma(sum(visible$visible))`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day8-part1-chart
#| fig-height: 8

visible |> 
  ggplot(aes(column, -row, fill = visible, label = tree)) + 
  geom_tile() +
  #geom_text(colour = aoc_black) +
  scale_fill_manual(values = c('FALSE' = aoc_yellow, 'TRUE' = aoc_dgreen)) +
  #coord_fixed() +
  theme_aoc_null() +
  labs(
    title = 'Visible trees'
  ) +
  guides(fill = 'none')

```


```{r}
#| label: read-day8-part2
#| fig-height: 8
#| eval: false
#| include: false

see_direction <- function(t) {
  n <- length(t)
  see <- accumulate(t, ~ c(.x, .y), .dir = 'backward')
  ex_me <- map(1:n, ~see[[.x]][-1])
  lower <- map(1:n, ~coalesce(sum(t[[.x]] > cummax(ex_me[[.x]]), 0)))
  first_higher <- map(1:n, ~coalesce(max(t[[.x]] <= cummax(ex_me[[.x]]),0)))
  unlist(map(1:n, ~lower[[.x]] + first_higher[[.x]]))
}

scenic <- visible |> 
  select(1:4) |> 
  group_by(row) |> 
  mutate(
    see_up = see_direction(tree),
    see_down = order_by(-column, see_direction(tree))
  ) |> 
  group_by(column) |> 
  mutate(
    see_right = see_direction(tree),
    see_left = order_by(-row, see_direction(tree)),
    scenic_score = see_up * see_down * see_right * see_left
  ) |> 
  ungroup()



highest_scenic <- scenic |> 
  filter(scenic_score == max(scenic_score))

scenic |> 
  ggplot(aes(column, -row, fill = scenic_score, label = scenic_score)) + 
  geom_tile() +
  #geom_text(colour = aoc_black) +
  scale_fill_gradient(high = aoc_dgreen, low = aoc_yellow) +
  #coord_fixed() +
  theme_aoc_null() +
  labs(
    title = 'Scenic scores for trees'
  ) +
  guides(fill = 'none')


stars <- stars + 0

#The highest scenic score for a tree is
#[`r comma(max(highest_scenic$scenic_score))`]{.aoc-green}. [*]{.aoc-yellow}

```

> Part 2 still to come


# Day 9: Rope Bridge

[Instructions](https://adventofcode.com/2022/day/9)


```{r}
#| label: read-day9-part1

df_9 <- tibble(lines = readLines('inputs/day9-part1.csv')) |> 
  separate(lines, into = c('direction', 'moves'), convert = TRUE) |> 
  uncount(moves) |> 
  mutate(
    row = row_number(),
    x = case_when(
      direction == 'R' ~ -1,
      direction == 'L' ~ 1,
      TRUE ~ 0
    ),
    y = case_when(
      direction == 'D' ~ -1,
      direction == 'U' ~ 1,
      TRUE ~ 0
    )
  ) |> 
  add_row(
    row = 0, x = 0, y = 0, .before = TRUE
  ) |> 
  mutate(
    heads_x = coalesce(cumsum(x), 0),
    heads_y = coalesce(cumsum(y))
  )

follow <- function(tail, head) {
  if(max(abs(head - tail)) <= 1) {return(tail)}
  map2_dbl(tail, head, ~ .x + sign(.y - .x))
}

df_9a <- df_9 |> 
  mutate(
    head = map2(heads_x, heads_y,  c)
  ) |> 
  mutate(
    tailxy = accumulate(head, follow, .init = c(0, 0))[-1]
  )  |> 
  group_by(row) |> 
  mutate(
    tails_x = pluck(unlist(tailxy), 1),
    tails_y = pluck(unlist(tailxy), 2)
  ) |> 
  ungroup()

visited <- df_9a |> 
  distinct(tails_x, tails_y) |> 
  nrow()

stars <- stars + 1

bind_rows(
  df_9a |>
    transmute(
      type = 'Heads', row, x = heads_x, y = heads_y
    ),
  df_9a |>
    transmute(
      type = 'Tails', row, x = tails_x, y = tails_y
    )
) |> 
  ggplot(aes(-x, y, colour = type)) +
  geom_path() +
  scale_colour_manual(values = c('Heads' = aoc_white, 'Tails' = aoc_green)) +
  theme_aoc_null() +
  labs(
    colour = NULL,
    title = 'Heads and tails paths'
  )

```

The number of positions visited is
[`r comma(visited)`]{.aoc-green}. [*]{.aoc-yellow}


```{r}
#| label: read-day9-part1b


df_9b <- df_9 |> 
  mutate(
    head = map2(heads_x, heads_y,  c)
  ) |> 
  mutate(
    tail1 = accumulate(head, follow, .init = c(0, 0))[-1],
    tail2 = accumulate(tail1, follow, .init = c(0, 0))[-1],
    tail3 = accumulate(tail2, follow, .init = c(0, 0))[-1],
    tail4 = accumulate(tail3, follow, .init = c(0, 0))[-1],
    tail5 = accumulate(tail4, follow, .init = c(0, 0))[-1],
    tail6 = accumulate(tail5, follow, .init = c(0, 0))[-1],
    tail7 = accumulate(tail6, follow, .init = c(0, 0))[-1],
    tail8 = accumulate(tail7, follow, .init = c(0, 0))[-1],
    tail9 = accumulate(tail8, follow, .init = c(0, 0))[-1]
  )  |> 
  group_by(row) |> 
  mutate(
    tails_x = pluck(unlist(tail9), 1),
    tails_y = pluck(unlist(tail9), 2)
  ) |> 
  ungroup()

visited_b <- df_9b |> 
  distinct(tails_x, tails_y) |> 
  nrow()


stars <- stars + 1

```

The number of positions visited by the ninth knot is
[`r comma(visited_b)`]{.aoc-green}. [*]{.aoc-yellow}

# Day 10: Cathode-Ray Tube

[Instructions](https://adventofcode.com/2022/day/10)

```{r}
#| label: read-day10-part1

df_10 <- tibble(lines = readLines('inputs/day10.csv')) |> 
  separate(lines, sep = ' ', into = c('instruction', 'moves'), convert = TRUE) |> 
  mutate(row = row_number()) |> 
  mutate(
    count = if_else(instruction == 'noop', 1, 2)
  ) |> 
  uncount(count) |> 
  add_row(moves = 0) |> 
  mutate(
    cycle = row_number(),
    a_moves = coalesce(row == lag(row) | is.na(row), FALSE) * coalesce(moves, 0),
    x = head(accumulate(a_moves, `+`, .init = 1), -1),
    signal_strength = cycle * x
  )

combined_ss <- df_10 |> 
  slice(20, 60, 100, 140, 180, 220) |> 
  summarise(signal_strength = sum(signal_strength)) |> 
  pull()

stars <- stars + 1


```

The combined signal strength is
[`r comma(combined_ss)`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day10-part2
#| eval: false
#| include: false

in_three <- function(x, y) {
   x >= y & x <= y + 3
}

df_10 |> 
  mutate(
    #display_column = cycle %% 40,
    #display_row = cycle %/% 40,
    position = 1:n() - 1,
    sprite = case_when(
      position == 0 ~ 1, 
      a_moves != 0 ~ x
    )
  ) |> 
  select(-row) |> 
  fill(sprite) |> 
  mutate(
    sprite = lead(sprite),
    visible = in_three(position, sprite)
  )


stars <- stars + 0


#The ... is
#[`r 999`]{.aoc-green}. [*]{.aoc-yellow}
```

# Day 11: Monkey in the Middle

[Instructions](https://adventofcode.com/2022/day/11)

> In progress

```{r}
#| label: read-day11-part1

df_11 <- tibble(lines = readLines('inputs/day11-eg.csv')) |> 
  #separate(lines, sep = ' ', into = c('instruction', 'moves'), convert = TRUE) |> 
  mutate(
    row = row_number(),
    from_monkey = case_when(
      str_sub(lines, 1, 2) == 'Mo' ~ parse_number(lines)
    ),
    worry_start = case_when(
      str_sub(lines, 3, 4) == 'St' ~ str_sub(lines, 19) |> 
        str_split(pattern = ', ')
    ),
    operation = case_when(
      str_sub(lines, 3, 4) == 'Op' ~ str_sub(lines, 20)
    ),
    test_divide = case_when(
      str_sub(lines, 3, 4) == 'Te' ~ parse_number(lines)
    ),
    true_monkey = case_when(
      str_sub(lines, 8, 8) == 't' ~ parse_number(lines)
    ),
    false_monkey = case_when(
      str_sub(lines, 8, 8) == 'f' ~ parse_number(lines)
    ),
    turn = from_monkey + 1  
  ) |> 
  fill(turn) |> 
  group_by(turn) |> 
  fill( from_monkey, worry_start, operation, test_divide, true_monkey, false_monkey) |> 
  filter(row == max(row)) |> 
  ungroup() |> 
  select(-lines, -row)

# need a function to to the following steps for each item in a turn
# and then add the items to the lists for the to_monkeys

x <- df_11 |>  
  unnest(worry_start) |> 
  mutate(
    item = row_number()
  )  |> 
  group_by(row = row_number()) |> 
  mutate(
    worry_inspect = eval(parse(text = str_replace_all(operation, 'old', worry_start))),
    worry_relief = worry_inspect %/% 3,
    test = worry_relief %% test_divide == 0,
    monkey_to = if_else(test, true_monkey, false_monkey)
  ) |> 
  ungroup()



```

# Total stars

The total number of [stars]{.aoc-yellow} earned is
[`r stars`]{.aoc-green}.

# Potential improvements

- Read files straight from website rather than copying, but this won't work for the example data
- Using a PAT for Github access from RStudio Cloud is painful
- Circle back to improve after reviewing other peoples code.
- Use the same Fira Code font for the charts
- Put a border around the charts

# Source code

The source code can be found at [github.com/JoDudding/advent-of-code](https://github.com/JoDudding/advent-of-code).

Last year's advent of code (that I'm doing this year) can be found [here](advent-of-code-2021.html).

```{bash}
#| label: quarto-preview-instruction
#| echo: false

# quarto preview index.qmd
# quarto render index.qmd

```