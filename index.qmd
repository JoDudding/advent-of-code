---
title : Advent of Code 2022
subtitle: "[adventofcode.com](https://adventofcode.com/){.aoc-yellow}"
#author: Jo Dudding
#date: today
format: 
  html:
    #embed-resources: true
    #standalone: true
    fig-width: 8
    fig-height: 4
    theme: ['advent-of-code.scss']
    highlight-style: nord
    toc: true
    toc_float: 
      collapsed: true
    code-fold: true  
execute: 
  echo: true
  warning: false
  message: false
knitr: 
  opts_knit: 
    root-dir: "`r here::here()`"
---

# Introduction

This analysis is my attempt at [adventofcode.com](https://adventofcode.com/) using R and Quarto.

Here's an overview from [adventofcode.com](https://adventofcode.com/).

> Santa's reindeer typically eat regular reindeer food, but they need a lot of magical energy to deliver presents on Christmas. For that, their favorite snack is a special type of [star]{.aoc-yellow} fruit that only grows deep in the jungle. The Elves have brought you on their annual expedition to the grove where the fruit grows.
> 
> To supply enough magical energy, the expedition needs to retrieve a minimum of [fifty stars]{.aoc-yellow} by December 25th. Although the Elves assure you that the grove has plenty of fruit, you decide to grab any fruit you see along the way, just in case.
> 
> Collect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants [one star]{.aoc-yellow}. Good luck!


```{r}
#| label: setup

library(tidyverse)
library(scales)
library(here)
library(gfonts)
library(patchwork)

options(
  dplyr.width = Inf,
  papersize = "a4",
  tab.width = 2,
  width = 80,
  max.print = 25,
  stringsAsFactors = FALSE,
  lubridate.week.start = 6,
  tibble.print_max = 25,
  tibble.print_min = 25,
  tibble.width = Inf,
  dplyr.summarise.inform = FALSE,
  tidyverse.quiet = TRUE
)

source('aoc-theme.r')

stars <- 0

```

# Day 1: Calorie Counting

[Instructions](https://adventofcode.com/2022/day/1)

```{r}
#| label: read-day1-part1
df1 <- tibble(cals = readLines('inputs/day1-part1.csv')) |>
  mutate(
    cals = as.numeric(cals),
    row = row_number(),
    elf = case_when(
      row == 1 ~ row,
      is.na(cals) ~ row
    )
  ) |>
  fill(elf) |>
  filter(!is.na(cals)) |>
  group_by(elf) |>
  summarise(cals = sum(cals)) |>
  ungroup() |>
  arrange(-cals)

stars <- stars + 1
```

The maximum calories carried by an elf is
[`r comma(max(df1$cals))`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day1-part2

top_3_cals <- df1 |>
  head(3) |>
  summarise(cals = sum(cals)) |>
  pull(cals)

stars <- stars + 1
```

The calories carried by the top three elves is
[`r comma(top_3_cals)`]{.aoc-green}. [*]{.aoc-yellow}

# Day 2: Rock Paper Scissors

[Instructions](https://adventofcode.com/2022/day/2)

```{r}
#| label: read-day2-part1
df2 <- tibble(strat = readLines('inputs/day2-part1.csv')) |>
  separate(strat, into = c('them', 'us')) |>
  mutate(
    shape = case_when(
      us == 'X' ~ 1,
      us == 'Y' ~ 2,
      us == 'Z' ~ 3
    ),
    outcome = case_when(
      them == 'A' & us == 'X' ~ 3,
      them == 'A' & us == 'Y' ~ 6,
      them == 'A' & us == 'Z' ~ 0,
      them == 'B' & us == 'X' ~ 0,
      them == 'B' & us == 'Y' ~ 3,
      them == 'B' & us == 'Z' ~ 6,
      them == 'C' & us == 'X' ~ 6,
      them == 'C' & us == 'Y' ~ 0,
      them == 'C' & us == 'Z' ~ 3
    ),
    score = shape + outcome
  ) 

stars <- stars + 1

```

The total points for this strategy are
[`r comma(sum(df2$score))`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day2-part2

df2_p2 <- df2 |>
  mutate(
    outcome = us,
    us = case_when(
      them == 'A' & outcome == 'X' ~ 'Z',
      them == 'A' & outcome == 'Y' ~ 'X',
      them == 'A' & outcome == 'Z' ~ 'Y',
      them == 'B' & outcome == 'X' ~ 'X',
      them == 'B' & outcome == 'Y' ~ 'Y',
      them == 'B' & outcome == 'Z' ~ 'Z',
      them == 'C' & outcome == 'X' ~ 'Y',
      them == 'C' & outcome == 'Y' ~ 'Z',
      them == 'C' & outcome == 'Z' ~ 'X'
    ),
    shape_points = case_when(
      us == 'X' ~ 1,
      us == 'Y' ~ 2,
      us == 'Z' ~ 3
    ),
    outcome_points = case_when(
      outcome =='X' ~ 0,
      outcome =='Y' ~ 3,
      outcome =='Z' ~ 6
    ),
    score = shape_points + outcome_points
  ) 

stars <- stars + 1
```

The total points for the updated strategy are
[`r comma(sum(df2_p2$score))`]{.aoc-green}. [*]{.aoc-yellow}


# Day 3: Rucksack Reorganization

[Instructions](https://adventofcode.com/2022/day/3)

```{r}
#| label: read-day3-part1

scoring3 <- tibble(
  contents_item = c(letters, LETTERS),
  priority = 1:52
)

df3 <- tibble(contents = readLines('inputs/day3-part1.csv')) |>
  mutate(
    rucksack = row_number(),
    len = str_length(contents),
    contents_item = str_split(contents, "")
  ) |>
  unnest(contents_item) |>
  group_by(rucksack) |>
  mutate(
    compartment = if_else(row_number() <= len / 2, 'a', 'b')
  ) 
  
df3_1 <- df3|>
  distinct(rucksack, contents_item, compartment) |>
  group_by(rucksack, contents_item) |>
  filter(n() > 1) |>
  ungroup() |>
  distinct(rucksack, contents_item) |>
  left_join(scoring3, by = 'contents_item')

stars <- stars + 1

```

The total priority for the rucksacks is
[`r comma(sum(df3_1$priority))`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day3-part2

df3_2 <- df3 |>
  mutate(
    trio = (rucksack - 1) %/% 3
  ) |>
  distinct(rucksack, contents_item, trio) |>
  group_by(trio, contents_item) |>
  filter(n()  == 3) |>
  ungroup() |>
  distinct(contents_item, trio) |>
  left_join(scoring3, by = 'contents_item') 

stars <- stars + 1
```

The total priority for the badges is
[`r comma(sum(df3_2$priority))`]{.aoc-green}. [*]{.aoc-yellow}


# Day 4: Camp Cleanup

[Instructions](https://adventofcode.com/2022/day/4)

```{r}
#| label: read-day4-part1

df4 <- tibble(sections = readLines('inputs/day4-part1.csv')) |> 
  separate(sections, into = c('elf1_min', 'elf1_max', 'elf2_min', 'elf2_max'), convert = TRUE) |> 
  mutate(pair = row_number())

df4_1 <- df4 |> 
  filter(
    (elf1_min <= elf2_min & elf1_max >= elf2_max) |
    (elf2_min <= elf1_min & elf2_max >= elf1_max) 
  ) 

stars <- stars + 1

```

The assignment pairs where one fully contains the other is
[`r comma(nrow(df4_1))`]{.aoc-green}. [*]{.aoc-yellow}


```{r}
#| label: read-day4-part2


df4_2 <- df4 |> 
  filter(
    (elf1_max >= elf2_min & elf1_max <= elf2_max) |
    (elf2_max >= elf1_min & elf2_max <= elf1_max)  
  )

stars <- stars + 1
```


The assignment pairs where they overlap is
[`r comma(nrow(df4_2))`]{.aoc-green}. [*]{.aoc-yellow}


# Day 5: Supply Stacks

[Instructions](https://adventofcode.com/2022/day/5)

```{r}
#| label: read-day5-part1

df5 <- readLines('inputs/day5-part1.csv')

movements <- tibble(crates = df5) |> 
  filter(cumsum(str_trim(crates) == '') > 0 & str_trim(crates) != '') |> 
  separate(crates, into = c('move', 'move_num', 'from', 'stack_from', 'to', 'stack_to'), sep = ' ', convert = TRUE) |> 
  select(-move, -from, -to) 

stack <- df5[cumsum(str_trim(df5) == '') == 0]

stack_nums <- (str_length(tail(stack, 1)) + 1) %/% 4
stack_seq <- seq(2, stack_nums * 4, by = 4)

stack_list <- map(stack_seq, ~rev(str_sub(stack, .x, .x)))
#names(stack_list) = paste0('stack_', 1:stack_nums)
adj_stack <- map(stack_list, ~ .x[str_trim(.x) != ''])


#' need to do
#' get the last item in the from list
#' add it to the end of the to list
#' update the from list to remove it
#' repeat for the number of moves


move <- function(stack_from, stack_to) {
  start_stack <- adj_stack[[stack_from]]
  end_stack <- adj_stack[[stack_to]]
  
  to_move <- tail(start_stack, 1)
  
  adj_stack[[stack_to]] <<- c(end_stack, to_move)
  adj_stack[[stack_from]] <<- start_stack[1:length(start_stack)-1]
}

move_times <- function(move_num, stack_from, stack_to) {
  for(i in 1:move_num) {move(stack_from, stack_to)}
}


pwalk(movements, move_times)


final_stack <- adj_stack

message <- paste(map(final_stack, ~tail(.x, 1)), collapse = '')

stars <- stars + 1

```

The crates on the top of each stack are
[`r message`]{.aoc-green}. [*]{.aoc-yellow}


```{r}
#| label: read-day5-part2

adj_stack <- map(stack_list, ~ .x[str_trim(.x) != ''])

move2 <- function(move_num, stack_from, stack_to) {
  start_stack <- adj_stack[[stack_from]]
  end_stack <- adj_stack[[stack_to]]
  
  to_move <- tail(start_stack, move_num)
  
  adj_stack[[stack_to]] <<- c(end_stack, to_move)
  
  adj_stack[[stack_from]] <<- start_stack[1:(length(start_stack)-move_num)] 
}

pwalk(movements, move2)

final_stack <- adj_stack

message2 <- paste(map(final_stack, ~tail(.x, 1)), collapse = '')


stars <- stars + 1
```

With the new crane the crates on the top of each stack are
[`r message2`]{.aoc-green}. [*]{.aoc-yellow}


# Day 6: Tuning Trouble

[Instructions](https://adventofcode.com/2022/day/6)

```{r}
#| label: read-day6-part1

raw_6 <- readLines('inputs/day6-part1.csv')

df_6 <- tibble(chars = str_split(raw_6, pattern = '')) |>  
  unnest(chars) |> 
  mutate(
    row = row_number(),
    marker = if_else(
      row <= 3,
      FALSE,
     chars != lag(chars, 3) & chars != lag(chars, 2) & chars != lag(chars, 1) &
     lag(chars, 1) != lag(chars, 3) & lag(chars, 1) != lag(chars, 2) & 
     lag(chars, 2) != lag(chars, 3)
    )
  )

sop <- df_6 |> 
  filter(marker == TRUE) |> 
  slice(1) |> 
  pull(row)

stars <- stars + 1

```

The start of packet marker is at
[`r comma(sop)`]{.aoc-green}. [*]{.aoc-yellow}


```{r}
#| label: read-day6-part2

chars <- unlist(str_split(raw_6, pattern = ''))

som <- map_dfc(0:13, ~lag(chars, .x)) |> 
  mutate(row = row_number()) |> 
  filter(row >= 14) |> 
  gather(-row, key = 'lag',value = 'value') |> 
  group_by(row) |> 
  summarise(
    n_distinct = n_distinct(value)
  ) |> 
  filter(n_distinct == 14) |> 
  slice(1) |> 
  pull(row)

stars <- stars + 1
```

The start of message marker is at
[`r comma(som)`]{.aoc-green}. [*]{.aoc-yellow}


# Day 7: No Space Left On Device

[Instructions](https://adventofcode.com/2022/day/7)

> Still in progress

```{r}
#| label: read-day7-part1
#| eval: false


# Given a path like c("/", "/a/", "/a/b"), and dir "c",
# return c("/", "/a", "/a/b", "/a/b/c")- that is, every folder it's in
cd <- function(path, dir) {
  if (!is.na(dir)) {
    if (dir == "..") {
      return(head(path, -1))
    }
    return(c(path, paste0(tail(path, 1), "/", dir)))
  }
  return(path)
}

# Keep track of the cd lines
dir_sizes <- raw_7 %>%
  select(x = instruct) |> 
  extract(x, "cd_dir", "cd (.*)", remove = FALSE) %>%
  mutate(
    path = c(accumulate(cd_dir, cd)),
    row = row_number()
  ) %>%
  unnest(path) %>%
  filter(str_detect(x, "\\d")) %>%
  separate(x, c("size", "file"), sep = " ", convert = TRUE) 

dir_summary <- raw_7 |> 
  mutate(
    path_row = case_when(! is.na(cd) ~ row)
  ) |>
  fill(path_row) |> 
  filter(type != 'command') |> 
  filter(! is.na(file_size)) |> 
  left_join(levels, by = 'path_row') |> 
  select(x = instruct, row, size = file_size, file_name, path)
  group_by(path) |> 
  summarise(
    file_size = sum(file_size, na.rm = TRUE),
    num_files = sum(type == 'file'),
    num_dir = sum(type == 'folder')
  ) |> 
  ungroup()

dir_summary |> 
  anti_join(dir_sizes, by = c('row', 'path'))


dir_summary |> 
  filter(file_name == 'rlhz.pbs')

dir_sizes |> 
  filter(file == 'rlhz.pbs')

raw_7 |> 
  filter(row <= 59) |> 
  filter(! is.na(cd) | file_name == 'rlhz.pbs') |> 
  tail()

path_sum <- dir_sizes %>%
  group_by(path) %>%
  summarize(size = sum(size))

# Part 1
dir_sizes %>%
  filter(size < 100000) %>%
  summarize(sum(size))

# Part 2
dir_sizes %>%
  filter(size > (45349983 + 30000000 - 70000000)) %>%
  summarize(min(size))



dir_summary |> 
  left_join(dir_sizes, by = 'path')



raw_7 <- tibble(instruct = readLines('inputs/day7-part1.csv')) |> 
  mutate(
    row = row_number(),
    command = case_when(
      str_sub(instruct, 1, 1) == '$' ~ str_sub(instruct, 3)
    ),
    #file = case_when(
    #  is.na(command) ~ str_split(instruct, pattern = ' ', n = 2, simplify = TRUE)
    #),
    file_size = as.numeric(str_extract(instruct, '([:alnum:]+)\\b')),
    file_name = if_else(
      !is.na(file_size),
      str_extract(instruct, '(\\b[:alnum:]+\\.[:alnum:]+)$'),
      str_extract(instruct, '(\\b[:alnum:]+)$')
    ),
    type = case_when(
      !is.na(command) ~ 'command',
      !is.na(file_size) ~ 'file',
      TRUE ~ 'folder'
    ),
    cd = case_when(str_sub(command, 1, 2) == 'cd' ~ str_sub(command, 4))
  )


levels <- raw_7 |> 
  filter(! is.na(cd)) |> 
  select(row, cd) |> 
  mutate(
    orig_cd = cd,
    level = cumsum(case_when(
      cd == '/' ~ 0,
      cd == '..' ~ -1,
      TRUE ~ 1
    )),
    cd = if_else(cd == '..', lag(cd, 2), cd),
    cd = if_else(cd == '..', lag(cd, 3), cd),
    cd = if_else(cd == '..', lag(cd, 4), cd),
    cd = if_else(cd == '..', lag(cd, 5), cd),
    cd = if_else(cd == '..', lag(cd, 6), cd),
    levelx = level
  ) |> 
  filter(row <= 57)
  spread(
    key = level, value = cd
  ) |> 
  gather(-row, -levelx, key = 'key', value = 'value') |> 
  mutate(key = as.integer(key)) |> 
  arrange(row, levelx) |> 
  filter(key <= levelx) |> 
  select(-levelx) |> 
  group_by(key) |> 
  fill(value) |> 
  ungroup() |> 
  group_by(row) |> 
  mutate(
    path = accumulate(value, paste, sep = '/')
  ) |> 
  rename(path_row = row)

dir_summary <- raw_7 |> 
  mutate(
    path_row = case_when(! is.na(cd) ~ row)
  ) |>
  fill(path_row) |> 
  filter(type != 'command') |> 
  left_join(levels, by = 'path_row') |> 
  #filter(path == '//brdsppd/bcfqd/lsprzlbf')
  group_by(path, value) |> 
  summarise(
    file_size = sum(file_size, na.rm = TRUE),
    num_files = sum(type == 'file'),
    num_dir = sum(type == 'folder')
  ) |> 
  ungroup()

## probably need to make sure a file is not counted twice

dir_summary |> 
  filter(file_size <= 100000) |> 
  summarise(file_size = sum(file_size)) |> 
  pull()


# not 1907645 - too high
  


stars <- stars + 0

```

The ... is
[`r 999`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day7-part2
#| eval: false

```


The ... is
[`r 999`]{.aoc-green}. [*]{.aoc-yellow}

# Day 8: Treetop Tree House

[Instructions](https://adventofcode.com/2022/day/8)

```{r}
#| label: read-day8-part1
#| fig-height: 8

raw_8 <- readLines('inputs/day8-part1.csv')

visible <- tibble(trees = raw_8) |> 
  mutate(
    tree = str_split(trees, ""),
    row = row_number()
    ) |> 
  group_by(row) |> 
  unnest(tree) |> 
  #filter(row == 1) |> 
  mutate(
    tree = as.numeric(tree),
    column = row_number(),
    row_down = cummax(tree),
    visible = if_else(
      row_number() == 1,
      TRUE,
      tree > lag(row_down)
    ),
    row_up = order_by(-column, cummax(tree)),
    visible = if_else(
      visible | row_number() == n(),
      TRUE,
      tree > lead(row_up)
    )
  ) |> 
  group_by(column) |> 
  mutate(
    row_right = cummax(tree),
    visible = if_else(
      visible | row_number() == 1,
      TRUE,
      tree > lag(row_right)
    ),
    row_left = order_by(-row, cummax(tree)),
    visible = if_else(
      visible | row_number() == n(),
      TRUE,
      tree > lead(row_left)
    ),
  ) |> 
  ungroup()



visible |> 
  ggplot(aes(column, -row, fill =  tree, label = tree)) + 
  geom_tile() +
  #geom_text(colour = aoc_black) +
  scale_fill_gradient(high = aoc_dgreen, low = aoc_yellow) +
  coord_fixed() +
  theme_aoc_null() +
  labs(
    title = 'Tree heights'
  ) +
  guides(fill = 'none')

stars <- stars + 1

```

The total number of visible trees is
[`r comma(sum(visible$visible))`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day8-part1-chart
#| fig-height: 8

visible |> 
  ggplot(aes(column, -row, fill = visible, label = tree)) + 
  geom_tile() +
  #geom_text(colour = aoc_black) +
  scale_fill_manual(values = c('FALSE' = aoc_yellow, 'TRUE' = aoc_dgreen)) +
  coord_fixed() +
  theme_aoc_null() +
  labs(
    title = 'Visible trees'
  ) +
  guides(fill = 'none')

```


```{r}
#| label: read-day8-part2
#| fig-height: 8
#| eval: false

see_direction <- function(t) {
  n <- length(t)
  see <- accumulate(t, ~ c(.x, .y), .dir = 'backward')
  ex_me <- map(1:n, ~see[[.x]][-1])
  lower <- map(1:n, ~coalesce(sum(t[[.x]] > cummax(ex_me[[.x]]), 0)))
  first_higher <- map(1:n, ~coalesce(max(t[[.x]] <= cummax(ex_me[[.x]]),0)))
  unlist(map(1:n, ~lower[[.x]] + first_higher[[.x]]))
}

scenic <- visible |> 
  select(1:4) |> 
  group_by(row) |> 
  mutate(
    see_up = see_direction(tree),
    see_down = order_by(-column, see_direction(tree))
  ) |> 
  group_by(column) |> 
  mutate(
    see_right = see_direction(tree),
    see_left = order_by(-row, see_direction(tree)),
    scenic_score = see_up * see_down * see_right * see_left
  ) |> 
  ungroup()



highest_scenic <- scenic |> 
  filter(scenic_score == max(scenic_score))

scenic |> 
  ggplot(aes(column, -row, fill = scenic_score, label = scenic_score)) + 
  geom_tile() +
  #geom_text(colour = aoc_black) +
  scale_fill_gradient(high = aoc_dgreen, low = aoc_yellow) +
  coord_fixed() +
  theme_aoc_null() +
  labs(
    title = 'Scenic scores for trees'
  ) +
  guides(fill = 'none')


stars <- stars + 0

#The highest scenic score for a tree is
#[`r comma(max(highest_scenic$scenic_score))`]{.aoc-green}. [*]{.aoc-yellow}

```

> Part 2 still to come


# Day 9: Rope Bridge

[Instructions](https://adventofcode.com/2022/day/9)


In progress:

- Need to see the current position of tail vs head
- Accumulate to collect the tail position
- Need the accumulate to use a function that looks at the lagged tail position



```{r}
#| label: read-day9-part1
#| fig-height: 8

df_9 <- tibble(lines = readLines('inputs/day9-part1.csv')) |> 
  separate(lines, into = c('direction', 'moves'), convert = TRUE) |> 
  uncount(moves) |> 
  mutate(
    row = row_number(),
    x = case_when(
      direction == 'R' ~ 1,
      direction == 'L' ~ -1,
      TRUE ~ 0
    ),
    y = case_when(
      direction == 'D' ~ 1,
      direction == 'U' ~ -1,
      TRUE ~ 0
    )
  ) |> 
  add_row(
    row = 0, x = 0, y = 0, .before = TRUE
  ) |> 
  mutate(
    heads_x = coalesce(cumsum(x), 0),
    heads_y = coalesce(cumsum(y))
  )

df_9 |> 
  #filter(row <= 11) |> 
  ggplot(aes(heads_x, -heads_y, label = row)) +
  geom_path() +
  geom_point(size = 5) +
  geom_text() +
  coord_fixed() +
  theme_aoc_null() +
  labs(
    title = 'Heads path'
  )
```



```{r}

#| label: read-day9-part1b
#| fig-height: 8
#| eval: false

head <- df_9$heads_x[1:4]
heads_y <- df_9$heads_y[1:4]

follow <- function(tail, head) {
  if (abs(head - tail) <= 1) {
    tail 
  } else {
    
  }
}


# accumulate




stars <- stars + 0

```

The ... is
[`r 999`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day9-part2



stars <- stars + 0
```

The ... is
[`r 999`]{.aoc-green}. [*]{.aoc-yellow}

# Day 10: Cathode-Ray Tube

[Instructions](https://adventofcode.com/2022/day/10)

```{r}
#| label: read-day10-part1

df_10 <- tibble(lines = readLines('inputs/day10.csv')) |> 
  separate(lines, sep = ' ', into = c('instruction', 'moves'), convert = TRUE) |> 
  mutate(row = row_number()) |> 
  mutate(
    count = if_else(instruction == 'noop', 1, 2)
  ) |> 
  uncount(count) |> 
  add_row(moves = 0) |> 
  mutate(
    cycle = row_number(),
    moves = coalesce(row == lag(row) | is.na(row), FALSE) * coalesce(moves, 0),
    x = head(accumulate(moves, `+`, .init = 1), -1),
    signal_strength = cycle * x
  ) 

combined_ss <- df_10 |> 
  slice(20, 60, 100, 140, 180, 220) |> 
  summarise(signal_strength = sum(signal_strength)) |> 
  pull()

stars <- stars + 1


```

The combined signal strength is
[`r comma(combined_ss)`]{.aoc-green}. [*]{.aoc-yellow}

```{r}
#| label: read-day10-part2



stars <- stars + 0
```

The ... is
[`r 999`]{.aoc-green}. [*]{.aoc-yellow}



# Total stars

The total number of [stars]{.aoc-yellow} earned is
[`r stars`]{.aoc-green}.

# Potential improvements

- Read files straight from website rather than copying, but this won't work for the example data
- Using a PAT for Github access from RStudio Cloud is painful
- Circle back to improve after reviewing other peoples code.
- Use the same Fira Code font for the charts

# Source code

The source code can be found at [github.com/JoDudding/advent-of-code](https://github.com/JoDudding/advent-of-code).

Last year's advent of code (that I'm doing this year) can be found [here](advent-of-code-2021.html).

```{bash}
#| label: quarto-preview-instruction
#| echo: false

# quarto preview index.qmd
# quarto render index.qmd

```